# Plan for v0.3.0 (issue #48)

├── beetle                  Consequential
├── buffer                  Preserve
├── code
│   ├── action.rs
│   ├── builder.rs          Rewrite             Move to graph
│   ├── ebb.rs
│   ├── enums.rs
│   ├── mod.rs
│   └── variable.rs
├── graph
│   ├── cft.rs
│   ├── convention.rs
│   ├── cost.rs
│   ├── dataflow.rs
│   ├── dep.rs
│   ├── mod.rs
│   ├── op.rs
│   └── resources.rs
├── jit
│   ├── engine.rs           Rewrite
│   ├── entry.rs            Rewrite
│   ├── factorial.rs        Consequential
│   └── mod.rs              Consequential
├── lib.rs                  Consequential
├── optimizer
│   ├── allocator           Preserve
│   ├── codegen.rs          Preserve
│   ├── fill.rs             Preserve
│   ├── mod.rs              Preserve
│   ├── moves.rs            Preserve
│   ├── simulation.rs       Delete
│   └── walker.rs           Preserve
├── target                  Preserve
├── util                    Preserve


## Future

These things won't be done now:

 - Things could become target-specific (issue #32 and beyond):
   - `Action`
   - `Register`
   - `Convention`
   - `op_cost`
   - `optimizer`

 - Divide `code` between `target`, `optimizer` and `jit`.

 - Divide `graph` between `target`, `optimizer` and `jit`.

 - Peephole optimize the `Dataflow` as it is constructed (issue #52).

 - Add instrumentation to the code as it is compiled (issue #33).


## Incrementally removing `simulate()`

By moving `simulate()` from callees to callers, we're approaching a point where every call to `simulate()` immediately follows a call to `code::build()`. At this point, the pair of calls can be replaced with a single call to `graph::build()` (which doesn't exist yet).


## Break and fix later

These things will have to be deleted and will later need to be rewritten:

 - random_ebb and related tests. The problem is that these tests compare the `EBB` retured by the optimizer to the input `EBB`, which will not exist because it will just be a (Dataflow, CFT) pair. The fix is to make a dumb, reliable algorithm with the same API as the optimizer, and use it to make a second `EBB` that can be used as a point of comparison.
